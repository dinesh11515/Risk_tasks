"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDeployedGaugeAddress = exports.deployGauge = exports.deployGaugeEstimateGas = exports.getDeployedCryptoPoolAddress = exports.deployCryptoPool = exports.deployCryptoPoolEstimateGas = exports.getDeployedStableMetaPoolAddress = exports.deployStableMetaPool = exports.deployStableMetaPoolEstimateGas = exports.getDeployedStablePlainPoolAddress = exports.deployStablePlainPool = exports.deployStablePlainPoolEstimateGas = void 0;
var ethers_1 = require("ethers");
var curve_1 = require("../curve");
var utils_1 = require("../utils");
var curve_lp_token_v5_json_1 = __importDefault(require("../constants/abis/curve_lp_token_v5.json"));
// ------- STABLE PLAIN POOLS -------
var _deployStablePlainPool = function (name, symbol, coins, A, fee, // %
assetType, implementationIdx, estimateGas) { return __awaiter(void 0, void 0, void 0, function () {
    var _A, _fee, _coins, contract, gas, gasLimit;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (name.length > 32)
                    throw Error("Max name length = 32");
                if (symbol.length > 10)
                    throw Error("Max symbol length = 10");
                if (![2, 3, 4].includes(coins.length))
                    throw Error("Invalid number of coins. Must be 2, 3 or 4");
                if (fee < 0.04)
                    throw Error("Fee must be >= 0.04%");
                if (fee > 1)
                    throw Error("Fee must be <= 1%");
                if (![0, 1, 2, 3].includes(assetType))
                    throw Error("Invalid assetType. Must be one of: 0 = USD, 1 = ETH, 2 = BTC, 3 = Other");
                if (![0, 1, 2, 3].includes(implementationIdx))
                    throw Error("Invalid implementationIdx. Must be one 0, 1, 2 or 3");
                _A = (0, utils_1.parseUnits)(A, 0);
                _fee = (0, utils_1.parseUnits)(fee, 8);
                _coins = coins.concat(Array(4 - coins.length).fill(ethers_1.ethers.constants.AddressZero));
                contract = curve_1.curve.contracts[curve_1.curve.constants.ALIASES.factory].contract;
                return [4 /*yield*/, contract.estimateGas.deploy_plain_pool(name, symbol, _coins, _A, _fee, assetType, implementationIdx, curve_1.curve.constantOptions)];
            case 1:
                gas = _a.sent();
                if (estimateGas)
                    return [2 /*return*/, gas.toNumber()];
                gasLimit = gas.mul(130).div(100);
                return [4 /*yield*/, curve_1.curve.updateFeeData()];
            case 2:
                _a.sent();
                return [4 /*yield*/, contract.deploy_plain_pool(name, symbol, _coins, _A, _fee, assetType, implementationIdx, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
            case 3: return [2 /*return*/, _a.sent()];
        }
    });
}); };
var deployStablePlainPoolEstimateGas = function (name, symbol, coins, A, fee, // %
assetType, implementationIdx) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, _deployStablePlainPool(name, symbol, coins, A, fee, assetType, implementationIdx, true)];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.deployStablePlainPoolEstimateGas = deployStablePlainPoolEstimateGas;
var deployStablePlainPool = function (name, symbol, coins, A, fee, // %
assetType, implementationIdx) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, _deployStablePlainPool(name, symbol, coins, A, fee, assetType, implementationIdx, false)];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.deployStablePlainPool = deployStablePlainPool;
var getDeployedStablePlainPoolAddress = function (tx) { return __awaiter(void 0, void 0, void 0, function () {
    var txInfo;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, tx.wait()];
            case 1:
                txInfo = _a.sent();
                return [2 /*return*/, txInfo.logs[0].address.toLowerCase()];
        }
    });
}); };
exports.getDeployedStablePlainPoolAddress = getDeployedStablePlainPoolAddress;
// ------- STABLE META POOLS -------
var _deployStableMetaPool = function (basePool, name, symbol, coin, A, fee, // %
implementationIdx, estimateGas) { return __awaiter(void 0, void 0, void 0, function () {
    var _A, _fee, contract, gas, gasLimit;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (name.length > 32)
                    throw Error("Max name length = 32");
                if (symbol.length > 10)
                    throw Error("Max symbol length = 10");
                if (fee < 0.04)
                    throw Error("Fee must be >= 0.04%");
                if (fee > 1)
                    throw Error("Fee must be <= 1%");
                if (![0, 1].includes(implementationIdx))
                    throw Error("Invalid implementationIdx. Must be one 0 or 1");
                _A = (0, utils_1.parseUnits)(A, 0);
                _fee = (0, utils_1.parseUnits)(fee, 8);
                contract = curve_1.curve.contracts[curve_1.curve.constants.ALIASES.factory].contract;
                return [4 /*yield*/, contract.estimateGas.deploy_metapool(basePool, name, symbol, coin, _A, _fee, implementationIdx, curve_1.curve.constantOptions)];
            case 1:
                gas = _a.sent();
                if (estimateGas)
                    return [2 /*return*/, gas.toNumber()];
                gasLimit = gas.mul(130).div(100);
                return [4 /*yield*/, curve_1.curve.updateFeeData()];
            case 2:
                _a.sent();
                return [4 /*yield*/, contract.deploy_metapool(basePool, name, symbol, coin, _A, _fee, implementationIdx, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
            case 3: return [2 /*return*/, _a.sent()];
        }
    });
}); };
var deployStableMetaPoolEstimateGas = function (basePool, name, symbol, coin, A, fee, // %
implementationIdx) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, _deployStableMetaPool(basePool, name, symbol, coin, A, fee, implementationIdx, true)];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.deployStableMetaPoolEstimateGas = deployStableMetaPoolEstimateGas;
var deployStableMetaPool = function (basePool, name, symbol, coin, A, fee, // %
implementationIdx) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, _deployStableMetaPool(basePool, name, symbol, coin, A, fee, implementationIdx, false)];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.deployStableMetaPool = deployStableMetaPool;
var getDeployedStableMetaPoolAddress = function (tx) { return __awaiter(void 0, void 0, void 0, function () {
    var txInfo;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, tx.wait()];
            case 1:
                txInfo = _a.sent();
                return [2 /*return*/, txInfo.logs[txInfo.logs.length - 3].address.toLowerCase()];
        }
    });
}); };
exports.getDeployedStableMetaPoolAddress = getDeployedStableMetaPoolAddress;
// ------- CRYPTO POOLS -------
var _deployCryptoPool = function (name, symbol, coins, A, gamma, midFee, // %
outFee, // %
allowedExtraProfit, feeGamma, adjustmentStep, maHalfTime, // Seconds
initialPrice, estimateGas) { return __awaiter(void 0, void 0, void 0, function () {
    var _gamma, _midFee, _outFee, _allowedExtraProfit, _feeGamma, _adjustmentStep, _initialPrice, contract, gas, gasLimit;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (name.length > 32)
                    throw Error("Max name length = 32");
                if (symbol.length > 10)
                    throw Error("Max symbol length = 10");
                if (coins.length !== 2)
                    throw Error("Invalid number of coins. Must be 2");
                if (coins[1] === coins[2])
                    throw Error("Coins must be different");
                if (A < 4000)
                    throw Error("A must be >= 4000");
                if (A > 4 * (Math.pow(10, 9)))
                    throw Error("A must be <= 4 * 10 ** 9");
                if (gamma < 1e-8)
                    throw Error("gamma must be >= 1e-8");
                if (gamma > 0.02)
                    throw Error("gamma must be <= 0.02");
                if (midFee < 0.005)
                    throw Error("midFee must be >= 0.005");
                if (midFee > 100)
                    throw Error("midFee must be <= 100");
                if (outFee < midFee)
                    throw Error("outFee must be >= midFee");
                if (outFee > 100)
                    throw Error("outFee must be <= 100");
                if (allowedExtraProfit < 0)
                    throw Error("allowedExtraProfit must be >= 0");
                if (allowedExtraProfit > 0.01)
                    throw Error("allowedExtraProfit must be <= 0.01");
                if (feeGamma < 0)
                    throw Error("feeGamma must be >= 0");
                if (feeGamma > 1)
                    throw Error("feeGamma must be <= 1");
                if (adjustmentStep < 0)
                    throw Error("adjustmentStep must be >= 0");
                if (adjustmentStep > 1)
                    throw Error("adjustmentStep must be <= 1");
                if (maHalfTime < 0)
                    throw Error("daoFee must be >= 0");
                if (maHalfTime > 604800)
                    throw Error("daoFee must be <= 604800");
                if (initialPrice < 1e-12)
                    throw Error("initialPrice must be >= 1e-12");
                if (initialPrice > 1e12)
                    throw Error("initialPrice must be <= 1e12");
                _gamma = (0, utils_1.parseUnits)(gamma);
                _midFee = (0, utils_1.parseUnits)(midFee, 8);
                _outFee = (0, utils_1.parseUnits)(outFee, 8);
                _allowedExtraProfit = (0, utils_1.parseUnits)(allowedExtraProfit);
                _feeGamma = (0, utils_1.parseUnits)(feeGamma);
                _adjustmentStep = (0, utils_1.parseUnits)(adjustmentStep);
                _initialPrice = (0, utils_1.parseUnits)(initialPrice);
                contract = curve_1.curve.contracts[curve_1.curve.constants.ALIASES.crypto_factory].contract;
                return [4 /*yield*/, contract.estimateGas.deploy_pool(name, symbol, coins, A, _gamma, _midFee, _outFee, _allowedExtraProfit, _feeGamma, _adjustmentStep, 5000000000, maHalfTime, _initialPrice, curve_1.curve.constantOptions)];
            case 1:
                gas = _a.sent();
                if (estimateGas)
                    return [2 /*return*/, gas.toNumber()];
                gasLimit = gas.mul(130).div(100);
                return [4 /*yield*/, curve_1.curve.updateFeeData()];
            case 2:
                _a.sent();
                return [4 /*yield*/, contract.deploy_pool(name, symbol, coins, A, _gamma, _midFee, _outFee, _allowedExtraProfit, _feeGamma, _adjustmentStep, 5000000000, // 50%
                    maHalfTime, _initialPrice, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
            case 3: return [2 /*return*/, _a.sent()];
        }
    });
}); };
var deployCryptoPoolEstimateGas = function (name, symbol, coins, A, gamma, midFee, // %
outFee, // %
allowedExtraProfit, feeGamma, adjustmentStep, maHalfTime, // Seconds
initialPrice) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, _deployCryptoPool(name, symbol, coins, A, gamma, midFee, outFee, allowedExtraProfit, feeGamma, adjustmentStep, maHalfTime, initialPrice, true)];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.deployCryptoPoolEstimateGas = deployCryptoPoolEstimateGas;
var deployCryptoPool = function (name, symbol, coins, A, gamma, midFee, // %
outFee, // %
allowedExtraProfit, feeGamma, adjustmentStep, maHalfTime, // Seconds
initialPrice) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, _deployCryptoPool(name, symbol, coins, A, gamma, midFee, outFee, allowedExtraProfit, feeGamma, adjustmentStep, maHalfTime, initialPrice, false)];
            case 1: return [2 /*return*/, _a.sent()];
        }
    });
}); };
exports.deployCryptoPool = deployCryptoPool;
var getDeployedCryptoPoolAddress = function (tx) { return __awaiter(void 0, void 0, void 0, function () {
    var txInfo, lpTokenAddress, contract;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, tx.wait()];
            case 1:
                txInfo = _a.sent();
                lpTokenAddress = txInfo.logs[0].address;
                contract = new ethers_1.Contract(lpTokenAddress, curve_lp_token_v5_json_1.default, curve_1.curve.provider);
                return [4 /*yield*/, contract.minter(curve_1.curve.constantOptions)];
            case 2: return [2 /*return*/, (_a.sent()).toLowerCase()];
        }
    });
}); };
exports.getDeployedCryptoPoolAddress = getDeployedCryptoPoolAddress;
// ------- GAUGE -------
var _deployGauge = function (pool, isCrypto, estimateGas) { return __awaiter(void 0, void 0, void 0, function () {
    var contractAddress, contract, gas, gasLimit;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                contractAddress = isCrypto ? curve_1.curve.constants.ALIASES.crypto_factory : curve_1.curve.constants.ALIASES.factory;
                contract = curve_1.curve.contracts[contractAddress].contract;
                return [4 /*yield*/, contract.estimateGas.deploy_gauge(pool, curve_1.curve.constantOptions)];
            case 1:
                gas = _a.sent();
                if (estimateGas)
                    return [2 /*return*/, gas.toNumber()];
                gasLimit = gas.mul(130).div(100);
                return [4 /*yield*/, curve_1.curve.updateFeeData()];
            case 2:
                _a.sent();
                return [4 /*yield*/, contract.deploy_gauge(pool, __assign(__assign({}, curve_1.curve.options), { gasLimit: gasLimit }))];
            case 3: return [2 /*return*/, _a.sent()];
        }
    });
}); };
var deployGaugeEstimateGas = function (pool, isCrypto) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
    switch (_a.label) {
        case 0: return [4 /*yield*/, _deployGauge(pool, isCrypto, true)];
        case 1: return [2 /*return*/, _a.sent()];
    }
}); }); };
exports.deployGaugeEstimateGas = deployGaugeEstimateGas;
var deployGauge = function (pool, isCrypto) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
    switch (_a.label) {
        case 0: return [4 /*yield*/, _deployGauge(pool, isCrypto, false)];
        case 1: return [2 /*return*/, _a.sent()];
    }
}); }); };
exports.deployGauge = deployGauge;
var getDeployedGaugeAddress = function (tx) { return __awaiter(void 0, void 0, void 0, function () {
    var txInfo;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, tx.wait()];
            case 1:
                txInfo = _a.sent();
                // @ts-ignore
                return [2 /*return*/, txInfo.events[0].args[txInfo.events[0].args.length - 1].toLowerCase()];
        }
    });
}); };
exports.getDeployedGaugeAddress = getDeployedGaugeAddress;
